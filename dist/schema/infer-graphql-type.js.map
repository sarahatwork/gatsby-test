{"version":3,"sources":["../../src/schema/infer-graphql-type.js"],"names":["inferObjectStructureFromNodes","GraphQLObjectType","GraphQLBoolean","GraphQLString","GraphQLFloat","GraphQLInt","GraphQLList","GraphQLUnionType","require","_","invariant","moment","mime","isRelative","isRelativeUrl","normalize","systemPath","oneLine","store","getNode","getNodes","getRootNodeId","joinPath","createPageDependency","createTypeName","createKey","extractFieldExamples","isEmptyObjectOrArray","ISO_8601_FORMAT","inferGraphQLType","exampleValue","selector","otherArgs","fieldName","split","pop","Array","isArray","headType","isObject","name","fields","inferredType","type","momentDate","utc","isValid","args","formatString","description","fromNow","difference","locale","resolve","object","date","JSON","parse","stringify","format","diff","isInteger","inferFromMapping","value","mapping","fieldSelector","types","matchedTypes","filter","isEmpty","console","log","findNode","fieldValue","path","linkedType","linkedNode","find","n","internal","id","nodeId","nodeObjectType","node","a","b","map","findLinkedNode","linkedField","inferFromFieldName","uniqBy","v","key","validateLinkedNode","validateField","field","findNodeType","linkedNodes","forEach","i","length","f","join","resolveType","data","result","findRootNode","rootNode","whileCount","rootNodeId","parent","undefined","shouldInferFile","nodes","looksLikeFile","isString","lookup","get","visit","current","fn","keys","Object","concat","proceed","isNormalInteger","str","test","isMatch","k","normalizedSelector","s","fullSelector","pathToOtherNode","dir","otherFileExists","some","absolutePath","inferFromUri","fileField","findLinkedFileNode","relativePath","fileLinkPath","parentFileNode","linkedFileNode","EXCLUDE_KEYS","children","config","getState","isRoot","inferredFields","each","nextSelector","inferredField","includes"],"mappings":"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","file":"infer-graphql-type.js","sourcesContent":["// @flow\nconst {\n  GraphQLObjectType,\n  GraphQLBoolean,\n  GraphQLString,\n  GraphQLFloat,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLUnionType,\n} = require(`graphql`)\nconst _ = require(`lodash`)\nconst invariant = require(`invariant`)\nconst moment = require(`moment`)\nconst mime = require(`mime`)\nconst isRelative = require(`is-relative`)\nconst isRelativeUrl = require(`is-relative-url`)\nconst normalize = require(`normalize-path`)\nconst systemPath = require(`path`)\nconst { oneLine } = require(`common-tags`)\n\nconst { store, getNode, getNodes, getRootNodeId } = require(`../redux`)\nconst { joinPath } = require(`../utils/path`)\nconst { createPageDependency } = require(`../redux/actions/add-page-dependency`)\nconst createTypeName = require(`./create-type-name`)\nconst createKey = require(`./create-key`)\nconst {\n  extractFieldExamples,\n  isEmptyObjectOrArray,\n} = require(`./data-tree-utils`)\n\nimport type { GraphQLOutputType } from \"graphql\"\nimport type {\n  GraphQLFieldConfig,\n  GraphQLFieldConfigMap,\n} from \"graphql/type/definition\"\n\nexport type ProcessedNodeType = {\n  name: string,\n  nodes: any[],\n  node: GraphQLFieldConfig<*, *>,\n  fieldsFromPlugins: any,\n  nodeObjectType: GraphQLOutputType,\n}\n\nconst ISO_8601_FORMAT = [\n  `YYYY`,\n  `YYYY-MM`,\n  `YYYY-MM-DD`,\n  `YYYYMMDD`,\n  `YYYY-MM-DDTHHZ`,\n  `YYYY-MM-DDTHH:mmZ`,\n  `YYYY-MM-DDTHHmmZ`,\n  `YYYY-MM-DDTHH:mm:ssZ`,\n  `YYYY-MM-DDTHHmmssZ`,\n  `YYYY-MM-DDTHH:mm:ss.SSSZ`,\n  `YYYY-MM-DDTHHmmss.SSSZ`,\n  `YYYY-[W]WW`,\n  `YYYY[W]WW`,\n  `YYYY-[W]WW-E`,\n  `YYYY[W]WWE`,\n  `YYYY-DDDD`,\n  `YYYYDDDD`,\n]\n\nfunction inferGraphQLType({\n  exampleValue,\n  selector,\n  ...otherArgs\n}): ?GraphQLFieldConfig<*, *> {\n  if (exampleValue == null || isEmptyObjectOrArray(exampleValue)) return null\n  let fieldName = selector.split(`.`).pop()\n\n  if (Array.isArray(exampleValue)) {\n    exampleValue = exampleValue[0]\n\n    if (exampleValue == null) return null\n\n    let headType\n    // If the array contains objects, than treat them as \"nodes\"\n    // and create an object type.\n    if (_.isObject(exampleValue)) {\n      headType = new GraphQLObjectType({\n        name: createTypeName(fieldName),\n        fields: inferObjectStructureFromNodes({\n          ...otherArgs,\n          exampleValue,\n          selector,\n        }),\n      })\n      // Else if the values are simple values, just infer their type.\n    } else {\n      let inferredType = inferGraphQLType({\n        ...otherArgs,\n        exampleValue,\n        selector,\n      })\n      invariant(\n        inferredType,\n        `Could not infer graphQL type for value: ${exampleValue}`\n      )\n\n      headType = inferredType.type\n    }\n    return { type: new GraphQLList(headType) }\n  }\n\n  // Check if this is a date.\n  // All the allowed ISO 8601 date-time formats used.\n  const momentDate = moment.utc(exampleValue, ISO_8601_FORMAT, true)\n  if (momentDate.isValid()) {\n    return {\n      type: GraphQLString,\n      args: {\n        formatString: {\n          type: GraphQLString,\n          description: oneLine`\n            Format the date using Moment.js' date tokens e.g.\n          \"date(formatString: \"YYYY MMMM DD)\"\n          See https://momentjs.com/docs/#/displaying/format/\n          for documentation for different tokens`,\n        },\n        fromNow: {\n          type: GraphQLBoolean,\n          description: oneLine`\n            Returns a string generated with Moment.js' fromNow function`,\n        },\n        difference: {\n          type: GraphQLString,\n          description: oneLine`\n            Returns the difference between this date and the current time.\n            Defaults to miliseconds but you can also pass in as the\n            measurement years, months, weeks, days, hours, minutes,\n            and seconds.`,\n        },\n        locale: {\n          type: GraphQLString,\n          description: oneLine`\n            Configures the locale Moment.js will use to format the date.\n          `,\n        },\n      },\n      resolve(object, { fromNow, difference, formatString, locale = `en` }) {\n        let date\n        if (object[fieldName]) {\n          date = JSON.parse(JSON.stringify(object[fieldName]))\n        } else {\n          return null\n        }\n        if (formatString) {\n          return moment\n            .utc(date, ISO_8601_FORMAT, true)\n            .locale(locale)\n            .format(formatString)\n        } else if (fromNow) {\n          return moment\n            .utc(date, ISO_8601_FORMAT, true)\n            .locale(locale)\n            .fromNow()\n        } else if (difference) {\n          return moment().diff(\n            moment.utc(date, ISO_8601_FORMAT, true).locale(locale),\n            difference\n          )\n        } else {\n          return date\n        }\n      },\n    }\n  }\n\n  switch (typeof exampleValue) {\n    case `boolean`:\n      return { type: GraphQLBoolean }\n    case `string`:\n      return { type: GraphQLString }\n    case `object`:\n      return {\n        type: new GraphQLObjectType({\n          name: createTypeName(fieldName),\n          fields: inferObjectStructureFromNodes({\n            ...otherArgs,\n            exampleValue,\n            selector,\n          }),\n        }),\n      }\n    case `number`:\n      return _.isInteger(exampleValue)\n        ? { type: GraphQLInt }\n        : { type: GraphQLFloat }\n    default:\n      return null\n  }\n}\n\nfunction inferFromMapping(\n  value,\n  mapping,\n  fieldSelector,\n  types\n): ?GraphQLFieldConfig<*, *> {\n  const matchedTypes = types.filter(\n    type => type.name === mapping[fieldSelector]\n  )\n  if (_.isEmpty(matchedTypes)) {\n    console.log(`Couldn't find a matching node type for \"${fieldSelector}\"`)\n    return null\n  }\n\n  const findNode = (fieldValue, path) => {\n    const linkedType = mapping[fieldSelector]\n    const linkedNode = _.find(\n      getNodes(),\n      n => n.internal.type === linkedType && n.id === fieldValue\n    )\n    if (linkedNode) {\n      createPageDependency({ path, nodeId: linkedNode.id })\n      return linkedNode\n    }\n    return null\n  }\n\n  if (_.isArray(value)) {\n    return {\n      type: new GraphQLList(matchedTypes[0].nodeObjectType),\n      resolve: (node, a, b, { fieldName }) => {\n        const fieldValue = node[fieldName]\n\n        if (fieldValue) {\n          return fieldValue.map(value => findNode(value, b.path))\n        } else {\n          return null\n        }\n      },\n    }\n  }\n\n  return {\n    type: matchedTypes[0].nodeObjectType,\n    resolve: (node, a, b, { fieldName }) => {\n      const fieldValue = node[fieldName]\n\n      if (fieldValue) {\n        return findNode(fieldValue, b.path)\n      } else {\n        return null\n      }\n    },\n  }\n}\n\nfunction findLinkedNode(value, linkedField, path) {\n  let linkedNode\n  // If the field doesn't link to the id, use that for searching.\n  if (linkedField) {\n    linkedNode = getNodes().find(n => n[linkedField] === value)\n    // Else the field is linking to the node's id, the default.\n  } else {\n    linkedNode = getNode(value)\n  }\n\n  if (linkedNode) {\n    if (path) createPageDependency({ path, nodeId: linkedNode.id })\n    return linkedNode\n  }\n  return null\n}\n\nfunction inferFromFieldName(value, selector, types): GraphQLFieldConfig<*, *> {\n  let isArray = false\n  if (_.isArray(value)) {\n    isArray = true\n    // Reduce values to nodes with unique types.\n    value = _.uniqBy(value, v => getNode(v).internal.type)\n  }\n\n  const key = selector.split(`.`).pop()\n  const [, , linkedField] = key.split(`___`)\n\n  const validateLinkedNode = linkedNode => {\n    invariant(\n      linkedNode,\n      oneLine`\n        Encountered an error trying to infer a GraphQL type for: \"${selector}\".\n        There is no corresponding node with the ${linkedField || `id`}\n        field matching: \"${value}\"\n      `\n    )\n  }\n  const validateField = (linkedNode, field) => {\n    invariant(\n      field,\n      oneLine`\n        Encountered an error trying to infer a GraphQL type for: \"${selector}\".\n        There is no corresponding GraphQL type \"${\n          linkedNode.internal.type\n        }\" available\n        to link to this node.\n      `\n    )\n  }\n\n  const findNodeType = node =>\n    types.find(type => type.name === node.internal.type)\n\n  if (isArray) {\n    const linkedNodes = value.map(v => findLinkedNode(v))\n    linkedNodes.forEach(node => validateLinkedNode(node))\n    const fields = linkedNodes.map(node => findNodeType(node))\n    fields.forEach((field, i) => validateField(linkedNodes[i], field))\n\n    let type\n    // If there's more than one type, we'll create a union type.\n    if (fields.length > 1) {\n      type = new GraphQLUnionType({\n        name: `Union_${key}_${fields.map(f => f.name).join(`__`)}`,\n        description: `Union interface for the field \"${key}\" for types [${fields\n          .map(f => f.name)\n          .join(`, `)}]`,\n        types: fields.map(f => f.nodeObjectType),\n        resolveType: data =>\n          fields.find(f => f.name == data.internal.type).nodeObjectType,\n      })\n    } else {\n      type = fields[0].nodeObjectType\n    }\n\n    return {\n      type: new GraphQLList(type),\n      resolve: (node, a, b = {}) => {\n        let fieldValue = node[key]\n        if (fieldValue) {\n          return fieldValue.map(value =>\n            findLinkedNode(value, linkedField, b.path)\n          )\n        } else {\n          return null\n        }\n      },\n    }\n  }\n\n  const linkedNode = findLinkedNode(value, linkedField)\n  validateLinkedNode(linkedNode)\n  const field = findNodeType(linkedNode)\n  validateField(linkedNode, field)\n  return {\n    type: field.nodeObjectType,\n    resolve: (node, a, b = {}) => {\n      let fieldValue = node[key]\n      if (fieldValue) {\n        const result = findLinkedNode(fieldValue, linkedField, b.path)\n        return result\n      } else {\n        return null\n      }\n    },\n  }\n}\n\nfunction findRootNode(node) {\n  // Find the root node.\n  let rootNode = node\n  let whileCount = 0\n  let rootNodeId\n  while (\n    (rootNodeId = getRootNodeId(rootNode) || rootNode.parent) &&\n    (getNode(rootNode.parent) !== undefined || getNode(rootNodeId)) &&\n    whileCount < 101\n  ) {\n    if (rootNodeId) {\n      rootNode = getNode(rootNodeId)\n    } else {\n      rootNode = getNode(rootNode.parent)\n    }\n    whileCount += 1\n    if (whileCount > 100) {\n      console.log(\n        `It looks like you have a node that's set its parent as itself`,\n        rootNode\n      )\n    }\n  }\n\n  return rootNode\n}\n\nfunction shouldInferFile(nodes, key, value) {\n  const looksLikeFile =\n    _.isString(value) &&\n    mime.lookup(value) !== `application/octet-stream` &&\n    // domains ending with .com\n    mime.lookup(value) !== `application/x-msdownload` &&\n    isRelative(value) &&\n    isRelativeUrl(value)\n\n  if (!looksLikeFile) {\n    return false\n  }\n\n  // Find the node used for this example.\n  let node = nodes.find(n => _.get(n, key) === value)\n\n  if (!node) {\n    // Try another search as our \"key\" isn't always correct e.g.\n    // it doesn't support arrays so the right key could be \"a.b[0].c\" but\n    // this function will get \"a.b.c\".\n    //\n    // We loop through every value of nodes until we find\n    // a match.\n    const visit = (current, selector = [], fn) => {\n      for (let i = 0, keys = Object.keys(current); i < keys.length; i++) {\n        const key = keys[i]\n        const value = current[key]\n\n        if (value === undefined || value === null) continue\n\n        if (typeof value === `object` || typeof value === `function`) {\n          visit(current[key], selector.concat([key]), fn)\n          continue\n        }\n\n        let proceed = fn(current[key], key, selector, current)\n\n        if (proceed === false) {\n          break\n        }\n      }\n    }\n\n    const isNormalInteger = str => /^\\+?(0|[1-9]\\d*)$/.test(str)\n\n    node = nodes.find(n => {\n      let isMatch = false\n      visit(n, [], (v, k, selector, parent) => {\n        if (v === value) {\n          // Remove integers as they're for arrays, which our passed\n          // in object path doesn't have.\n          const normalizedSelector = selector\n            .map(s => (isNormalInteger(s) ? `` : s))\n            .filter(s => s !== ``)\n          const fullSelector = `${normalizedSelector.join(`.`)}.${k}`\n          if (fullSelector === key) {\n            isMatch = true\n            return false\n          }\n        }\n\n        // Not a match so we continue\n        return true\n      })\n\n      return isMatch\n    })\n\n    // Still no node.\n    if (!node) {\n      return false\n    }\n  }\n\n  const rootNode = findRootNode(node)\n\n  // Only nodes transformed (ultimately) from a File\n  // can link to another File.\n  if (rootNode.internal.type !== `File`) {\n    return false\n  }\n\n  const pathToOtherNode = normalize(joinPath(rootNode.dir, value))\n  const otherFileExists = getNodes().some(\n    n => n.absolutePath === pathToOtherNode\n  )\n  return otherFileExists\n}\n\n// Look for fields that are pointing at a file — if the field has a known\n// extension then assume it should be a file field.\nfunction inferFromUri(key, types, isArray) {\n  const fileField = types.find(type => type.name === `File`)\n\n  if (!fileField) return null\n\n  return {\n    type: isArray\n      ? new GraphQLList(fileField.nodeObjectType)\n      : fileField.nodeObjectType,\n    resolve: (node, a, { path }) => {\n      const fieldValue = node[key]\n\n      if (!fieldValue) {\n        return null\n      }\n\n      const findLinkedFileNode = relativePath => {\n        // Use the parent File node to create the absolute path to\n        // the linked file.\n        const fileLinkPath = normalize(\n          systemPath.resolve(parentFileNode.dir, relativePath)\n        )\n\n        // Use that path to find the linked File node.\n        const linkedFileNode = _.find(\n          getNodes(),\n          n => n.internal.type === `File` && n.absolutePath === fileLinkPath\n        )\n        if (linkedFileNode) {\n          createPageDependency({\n            path,\n            nodeId: linkedFileNode.id,\n          })\n          return linkedFileNode\n        } else {\n          return null\n        }\n      }\n\n      // Find the File node for this node (we assume the node is something\n      // like markdown which would be a child node of a File node).\n      const parentFileNode = findRootNode(node)\n\n      // Find the linked File node(s)\n      if (isArray) {\n        return fieldValue.map(relativePath => findLinkedFileNode(relativePath))\n      } else {\n        return findLinkedFileNode(fieldValue)\n      }\n    },\n  }\n}\n\ntype inferTypeOptions = {\n  nodes: Object[],\n  types: ProcessedNodeType[],\n  selector?: string,\n  exampleValue?: Object,\n}\n\nconst EXCLUDE_KEYS = {\n  id: 1,\n  parent: 1,\n  children: 1,\n}\n\n// Call this for the top level node + recursively for each sub-object.\n// E.g. This gets called for Markdown and then for its frontmatter subobject.\nexport function inferObjectStructureFromNodes({\n  nodes,\n  types,\n  selector,\n  exampleValue = extractFieldExamples(nodes),\n}: inferTypeOptions): GraphQLFieldConfigMap<*, *> {\n  const config = store.getState().config\n  const isRoot = !selector\n  const mapping = config && config.mapping\n\n  // Ensure nodes have internal key with object.\n  nodes = nodes.map(n => (n.internal ? n : { ...n, internal: {} }))\n\n  const inferredFields = {}\n  _.each(exampleValue, (value, key) => {\n    // Remove fields common to the top-level of all nodes.  We add these\n    // elsewhere so don't need to infer their type.\n    if (isRoot && EXCLUDE_KEYS[key]) return\n\n    // Several checks to see if a field is pointing to custom type\n    // before we try automatic inference.\n    const nextSelector = selector ? `${selector}.${key}` : key\n    const fieldSelector = `${nodes[0].internal.type}.${nextSelector}`\n\n    let fieldName = key\n    let inferredField\n\n    // First check for manual field => type mappings in the site's\n    // gatsby-config.js\n    if (mapping && _.includes(Object.keys(mapping), fieldSelector)) {\n      inferredField = inferFromMapping(value, mapping, fieldSelector, types)\n\n      // Second if the field has a suffix of ___node. We use then the value\n      // (a node id) to find the node and use that node's type as the field\n    } else if (_.includes(key, `___NODE`)) {\n      ;[fieldName] = key.split(`___`)\n      inferredField = inferFromFieldName(value, nextSelector, types)\n\n      // Third if the field (whether a string or array of string(s)) is\n      // pointing to a file (from another file).\n    } else if (\n      nodes[0].internal.type !== `File` &&\n      ((_.isString(value) && shouldInferFile(nodes, nextSelector, value)) ||\n        (_.isArray(value) &&\n          value.length === 1 &&\n          _.isString(value[0]) &&\n          shouldInferFile(nodes, `${nextSelector}[0]`, value[0])))\n    ) {\n      inferredField = inferFromUri(key, types, _.isArray(value))\n    }\n\n    // Finally our automatic inference of field value type.\n    if (!inferredField) {\n      inferredField = inferGraphQLType({\n        nodes,\n        types,\n        exampleValue: value,\n        selector: selector ? `${selector}.${key}` : key,\n      })\n    }\n\n    if (!inferredField) return\n\n    // Replace unsupported values\n    inferredFields[createKey(fieldName)] = inferredField\n  })\n\n  return inferredFields\n}\n"]}